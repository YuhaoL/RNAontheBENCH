<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Pierre-Luc Germain" />

<meta name="date" content="2016-03-20" />

<title>RNAontheBENCH</title>

<meta name="viewport" content="width=device-width, initial-scale=1" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>



</head>

<body>

<style type="text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<div class="container-fluid main-container">





<div class="fluid-row" id="header">


<h1 class="title">RNAontheBENCH</h1>
<h4 class="author"><em>Pierre-Luc Germain</em></h4>
<h4 class="date"><em>2016-03-20</em></h4>

</div>

<div id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#installing-the-package-and-fetching-the-data"><span class="toc-section-number">2</span> Installing the package and fetching the data</a><ul>
<li><a href="#install-the-package"><span class="toc-section-number">2.1</span> Install the package</a></li>
<li><a href="#download-the-data-and-analyze-it-with-your-method-of-choice"><span class="toc-section-number">2.2</span> Download the data and analyze it with your method of choice</a></li>
<li><a href="#make-sure-your-expression-matrices-are-formatted-in-the-right-way"><span class="toc-section-number">2.3</span> Make sure your expression matrices are formatted in the right way</a></li>
</ul></li>
<li><a href="#benchmarking-quantification"><span class="toc-section-number">3</span> Benchmarking quantification</a><ul>
<li><a href="#the-benchmarkwrapper-function"><span class="toc-section-number">3.1</span> The benchmarkWrapper() function</a><ul>
<li><a href="#example-usage"><span class="toc-section-number">3.1.1</span> Example usage</a></li>
</ul></li>
</ul></li>
<li><a href="#benchmarking-differential-expression-analysis-dea"><span class="toc-section-number">4</span> Benchmarking differential expression analysis (DEA)</a><ul>
<li><a href="#comparing-differential-expression-calls-to-the-nanostring-data"><span class="toc-section-number">4.1</span> Comparing differential expression calls to the Nanostring data</a></li>
<li><a href="#comparing-differential-expression-calls-to-the-known-differences-between-spike-in-mixes"><span class="toc-section-number">4.2</span> Comparing differential expression calls to the known differences between spike-in mixes</a><ul>
<li><a href="#a-note-regarding-spike-in-normalization"><span class="toc-section-number">4.2.1</span> A note regarding spike-in normalization</a></li>
</ul></li>
<li><a href="#comparing-differential-expression-calls-within-and-across-seqc-groups"><span class="toc-section-number">4.3</span> Comparing differential expression calls within and across SEQC groups</a></li>
</ul></li>
<li><a href="#reporting-issues"><span class="toc-section-number">5</span> Reporting issues</a></li>
</ul>
</div>

<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>This package provides empirical and computational resources for benchmarking RNAseq analysis methods, harnessing a number of features:</p>
<ul>
<li>a RNAseq dataset from 12 human iPSC lines all including ExFold ERCC spike-ins (92 transcripts in known concentrations, some of which are differentially-expressed across mixes), as well as an additional validation dataset of 6 samples</li>
<li>a panel of 150 genes (including multiple isoforms for some genes) measured, in the same samples, by the very precise Nanostring nCounter technology</li>
<li>a set of internal, ‘genetic controls’ (genes with different copy-numbers and known to be expressed linearly with copy-numbers)</li>
<li>accuracy metrics based on feature-wise z-scores across samples, in order to assess differential expression accuracy.</li>
</ul>
<p>This help will guide you through its main usage.</p>
</div>
<div id="installing-the-package-and-fetching-the-data" class="section level1">
<h1><span class="header-section-number">2</span> Installing the package and fetching the data</h1>
<div id="install-the-package" class="section level2">
<h2><span class="header-section-number">2.1</span> Install the package</h2>
<p>To install the package, download it and install it using the following R command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;path/to/RNAontheBENCH.tar.gz&quot;</span>, <span class="dt">repos=</span><span class="ot">NULL</span>)</code></pre></div>
<p>Alternatively, if you have <code>devtools</code> installed you can install the package directly from the git repository using:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(devtools)
<span class="kw">install_git</span>(<span class="st">&quot;https://github.com/plger/RNAontheBENCH&quot;</span>)</code></pre></div>
<p>Once the package is installed, you can load it and access the vignette for some examples:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(RNAontheBENCH)
<span class="kw">vignette</span>(<span class="st">&quot;RNAontheBENCH&quot;</span>)</code></pre></div>
</div>
<div id="download-the-data-and-analyze-it-with-your-method-of-choice" class="section level2">
<h2><span class="header-section-number">2.2</span> Download the data and analyze it with your method of choice</h2>
<p>The benchmark is made using a specific dataset of stranded Truseq mRNA-seq libraries (Ribozero) with 100bp paired-end reads, coming from human induced pluripotent stem cell lines harbouring copy-number alterations of the 7q11.23 region. The RNA-seq data was published in <a href="http://www.ncbi.nlm.nih.gov/pubmed/25501393">Adamo A, Atashpaz S, Germain PL et al., <i>Nature Genetics</i> 2015, 2:132-41</a>, and is available through the <a href="http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE63058">GEO series GSE63055</a>.</p>
<p>You will need to download samples GSM1538995 through GSM1539007, and quantify them using your method of choice. Specifically, the following samples should be analyzed and given the names below:</p>
<table>
<thead>
<tr class="header">
<th align="left">Sample name</th>
<th align="left">GEO ID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">AJ80</td>
<td align="left">GSM1538995</td>
</tr>
<tr class="even">
<td align="left">AJ81</td>
<td align="left">GSM1538996</td>
</tr>
<tr class="odd">
<td align="left">AJ82</td>
<td align="left">GSM1538997</td>
</tr>
<tr class="even">
<td align="left">AJ83</td>
<td align="left">GSM1539001</td>
</tr>
<tr class="odd">
<td align="left">AJ84</td>
<td align="left">GSM1539002</td>
</tr>
<tr class="even">
<td align="left">AJ86</td>
<td align="left">GSM1539003</td>
</tr>
<tr class="odd">
<td align="left">AJ87</td>
<td align="left">GSM1539004</td>
</tr>
<tr class="even">
<td align="left">AJ89</td>
<td align="left">GSM1538999</td>
</tr>
<tr class="odd">
<td align="left">AJ90</td>
<td align="left">GSM1539005</td>
</tr>
<tr class="even">
<td align="left">AJ91</td>
<td align="left">GSM1539006</td>
</tr>
<tr class="odd">
<td align="left">AJ92</td>
<td align="left">GSM1539007</td>
</tr>
<tr class="even">
<td align="left">AJ93</td>
<td align="left">GSM1539008</td>
</tr>
</tbody>
</table>
<p>For reasons of comparability, we recommend using the NCBI GRCh38 genome, more specifically the sequence file <code>GCA_000001405.15_GRCh38_no_alt_analysis_set.fna</code> supplemented with the sequence of the ERCC spike-ins, and the corresponding gtf file also supplemented with the spike-in annotation.</p>
<p>Keep in mind that the libraries are stranded (ISR in the Sailfish/Salmon nomenclature, fr-firststrand in the Tuxedo nomenclature).</p>
<p>For the validation dataset, the samples are the following:</p>
<table>
<thead>
<tr class="header">
<th align="left">Sample name</th>
<th align="left">GEO ID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CFG.sh2</td>
<td align="left">GSM1539030</td>
</tr>
<tr class="even">
<td align="left">CFG.shCTR</td>
<td align="left">GSM1539029</td>
</tr>
<tr class="odd">
<td align="left">c3391S.sh2</td>
<td align="left">GSM1539042</td>
</tr>
<tr class="even">
<td align="left">c3391S.shCTR</td>
<td align="left">GSM1539041</td>
</tr>
<tr class="odd">
<td align="left">w306o.shCTR</td>
<td align="left">GSM1539037</td>
</tr>
<tr class="even">
<td align="left">w306o.sh2</td>
<td align="left">GSM1539038</td>
</tr>
</tbody>
</table>
<p>Finally, some functions (see below) can also be applied on the SEQC dataset. For more information on that dataset, see <a href="http://doi.org/10.1038/nbt.2957">Su et al. (2014) “A comprehensive assessment of RNA-seq accuracy, reproducibility and information content by the Sequencing Quality Control Consortium”, Nature Biotechnology, 32(9), 903–14</a>.</p>
</div>
<div id="make-sure-your-expression-matrices-are-formatted-in-the-right-way" class="section level2">
<h2><span class="header-section-number">2.3</span> Make sure your expression matrices are formatted in the right way</h2>
<p>The package expects expression matrices to have refseq ID or gene symbols as row names, and sample names (e.g. `AJ80’, as indicated in the tables above) as column headers.</p>
<p>Expression values can be read/fragments counts, FPKM, or TPM, and will be automically converted to TPM.</p>
<p>If you do not provide a gene-level quantification, transcripts will automatically be summed to genes.</p>
</div>
</div>
<div id="benchmarking-quantification" class="section level1">
<h1><span class="header-section-number">3</span> Benchmarking quantification</h1>
<p>Benchmarking a quantification can be done using a series of functions making specific comparisons (see <code>?compareWithNanostring</code>, <code>?analyzeSpikein</code>, <code>?compareWithPCR</code>, and <code>?compareSimulated</code>), or through the <code>benchmarkWrapper()</code> function, which calls all other functions on the analysed datasets and wraps the results in an html page.</p>
<div id="the-benchmarkwrapper-function" class="section level2">
<h2><span class="header-section-number">3.1</span> The benchmarkWrapper() function</h2>
<p>To avoid confusion, it is best to</p>
<ol style="list-style-type: decimal">
<li>rename the quantification files to <code>w12.transcripts.quant</code> (and eventually <code>w12.genes.quant</code>) for the 12-samples dataset, <code>w6.transcripts.quant</code> for the 6-samples dataset, and <code>simulated.quant</code> for the simulated data;</li>
<li>put your quantification files in the folder where you want the results of the analyis to be saved;</li>
<li>call the package using</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">benchmarkWrapper</span>(<span class="st">&quot;folder_containing_quantification&quot;</span>, <span class="st">&quot;analysis_name&quot;</span>, <span class="dt">qt=</span><span class="st">&quot;FPKM&quot;</span>)</code></pre></div>
<p>where ‘qt’ indicates the unit of the expression matrices (either ‘COUNTS’, ‘FPKM’, or ‘TPM’).</p>
<p>It is possible to run the benchmarkWrapper function even if only one dataset has been quantified. See <code>?benchmarkWrapper</code> for an example.</p>
<p>The benchmarkWrapper function calls a number of functions from the package (<code>compareWithNanostring</code>, <code>analyzeSpikein</code>, <code>compareWithPCR</code>, and <code>compareSimulated</code>), each of which can be called separately for further options (please see the help entry of each function for more detail). In addition, the benchmarkWrapper function generates a html file for browsing the results of the analysis.</p>
<div id="example-usage" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Example usage</h3>
<p>You can test the benchmarkWrapper function using the example data included in the package. We first load the data (two count matrices produced by featureCounts on the Tophat alignment, one for gene-level counts and the other for transcript-level), and save it in the folder in which we’ll want to save the results of the benchmark:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;RNAontheBENCH&quot;</span>)
<span class="kw">data</span>(exampledata)
<span class="kw">dir.create</span>(<span class="st">&quot;example&quot;</span>)
<span class="kw">write.table</span>(exampleTranscriptLevel,<span class="st">&quot;w12.transcripts.quant&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,<span class="dt">quote=</span>F)
<span class="kw">write.table</span>(exampleGeneLevel,<span class="st">&quot;w12.genes.quant&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,<span class="dt">quote=</span>F)</code></pre></div>
<pre><code>## Loading required package: MASS</code></pre>
<pre><code>## Loading required package: edgeR</code></pre>
<pre><code>## Loading required package: limma</code></pre>
<pre><code>## 
## Attaching package: 'RNAontheBENCH'</code></pre>
<pre><code>## The following object is masked from 'package:limma':
## 
##     zscore</code></pre>
<p>(Of note, to reduce their size the matrices contain only spike-ins, genes/transcripts of the Nanostring panel, as well as features with a certain number of reads assigned to them).</p>
<p>Then we call the function, specifying that the expression values are counts:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">benchmarkWrapper</span>(<span class="st">&quot;example&quot;</span>, <span class="st">&quot;tophat.featureCount&quot;</span>, <span class="dt">qt=</span><span class="st">&quot;counts&quot;</span>)</code></pre></div>
<p>A number of files will be saved in the “example” folder, including an html file allowing to browse these results.</p>
</div>
</div>
</div>
<div id="benchmarking-differential-expression-analysis-dea" class="section level1">
<h1><span class="header-section-number">4</span> Benchmarking differential expression analysis (DEA)</h1>
<p>The package also includes a number of functions to benchmark differential expression analysis methods, based either</p>
<ol style="list-style-type: decimal">
<li>on the Nanostring data</li>
<li>on the known concentrations of the spike-in mixes</li>
<li>on the in-group/out-group comparison of the SEQC dataset.</li>
</ol>
<p>For differential expression methods which take a count matrix as input (e.g. edgeR, DESeq, etc), functions are included which take the count matrix, run the analysis, and benchmark the results. For other methods, such as Cuffdiff, it is necessary to provide the analysis results as a data.frame with gene or transcript IDs are row.names, and with at least the columns “p” (for p-value), “log2FC”, and “fdr”.</p>
<p>(Note: to avoid differences due solely to FDR calculation, all comparisons are based on uncorrected p-values; moreover, where possible the TMM normalization is applied to all methods.)</p>
<div id="comparing-differential-expression-calls-to-the-nanostring-data" class="section level2">
<h2><span class="header-section-number">4.1</span> Comparing differential expression calls to the Nanostring data</h2>
<p>To comapre differential expression calls to nanostring, you can simply use the <code>deNanostring()</code> function, providing your count matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(exampledata)
<span class="kw">deNanostring</span>( exampleGeneLevel, <span class="dt">method=</span><span class="st">&quot;edgeR&quot;</span>, <span class="dt">norm=</span><span class="st">&quot;TMM&quot;</span>, 
   <span class="dt">quantification=</span><span class="st">&quot;Tophat-featureCounts&quot;</span>)</code></pre></div>
<p><img src="figure-html/deNanostringEG-1.png"/></p
<p>This function performs the specified DEA analysis, and benchmarks the results by comparing them to a t-test applied to the log-transformed Nanostring measurements, using by default a p-value of 0.01 to identify a gene as differentially-expressed (this can be specified with the ‘threshold’ argument of the <code>deNanostring()</code> function). The figure plotted provides some measures of accuracy, a comparison of the p-values, a comparison of the foldchanges, as well as a Receiver-Operator Characteristic (ROC) curve (and the area under it).</p>
<p>If you have the results from a DEA analysis performed outside R, such as from Cuffdiff, you simply need to reformat them to a data.frame with gene/transcript IDs are row.names, and with at least the columns “p” (for p-value) and “log2FC”. You can then provide it to the <code>deNanostring.compare()</code> to produce the same diagnostic plots.</p>
</div>
<div id="comparing-differential-expression-calls-to-the-known-differences-between-spike-in-mixes" class="section level2">
<h2><span class="header-section-number">4.2</span> Comparing differential expression calls to the known differences between spike-in mixes</h2>
<p>Samples from both the datasets in this study and the SEQC dataset where spiked-in with two different mixes containing the same ERCC RNAs albeit in different concentration. These known differences can therefore be used to assess differential expression analyses. Of note, the ERCC spike-ins are neither spliced, nor overlapping any other genomic features, and as such they are more simple to map and quantify than most transcripts. However, they have the advantage of having both a very precisely known abundance and, unlike simulations (which are inevitably based on models), authentic experimental variation.</p>
<p>Once again, a function performs (for available methods) the differential expression call and its benchmark:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">deSpikein</span>( exampleGeneLevel, <span class="dt">method=</span><span class="st">&quot;edgeR&quot;</span>, <span class="dt">norm=</span><span class="st">&quot;TMM&quot;</span>, 
   <span class="dt">quantification=</span><span class="st">&quot;Tophat-featureCounts&quot;</span>)</code></pre></div>
<p><img src="figure-html/deSpikeinEG-1.png"/></p
<p>The function returns the differential expression calls, and produces a figure with six panels: 
<ul>
<li>A: The ROC curve, which gives a non-parametric assessment of the method.</li>
<li>B: A histogram of p-values and fdr.</li>
<li>C: Curves of the specificity and sensitivity over different p-value thresholds (this is parametric!), as well as the area under each curve.</li>
<li>D: Same as C, except using FDR values.</li>
<li>E: Error in estimated log2(foldchange) as a function of p-value. * F: P-values across the different (real) foldchanges between mixes.</li>
</ul>
</p>
<p>Of note, the function can take as input either the count data from the dataset used in this study, or from the SEQC data.</p>
<p>All the actual benchmarking and the generation of the plots is done by the function <code>deSpikein.compare()</code>, which is called by the <code>deSpikein()</code> function. This means that you can perform the analysis yourself, or import an external one (e.g. Cuffdiff), and pass it to the function. You simple need to make sure that the data is formatted as a data.frame with gene/transcript IDs are row.names, and with at least the columns “p” (for p-value), “log2FC” and “fdr”. Note, however, that this will not used the ‘homogenized spike-in normalization’ (see below).</p>
<p>Sleuth users can use the <code>sleuthWrapper()</code> function, which performs the analysis with homogenized spike-in normalization and benchmark the results.</p>
<div id="a-note-regarding-spike-in-normalization" class="section level3">
<h3><span class="header-section-number">4.2.1</span> A note regarding spike-in normalization</h3>
<p>Spike-ins are loaded in the total RNA when preparing the libraries, and depending on the setting loading there can be variations in loading. For this reason, all spike-in based benchmarks in this package normalize the spike-ins separately from the rest of the transcriptome. Since a considerabe proportion of the spike-ins are differentially-expressed across mixes, the spike-in mixes are “homogenized” for the purpose of calculating normalization factors (dividing the quantifications by their expected foldchange; see <code>?homomixes</code>). If you want to disable this feature, simply perform the differential analysis yourself, and use the <code>deSpikein.compare()</code> function.</p>
</div>
</div>
<div id="comparing-differential-expression-calls-within-and-across-seqc-groups" class="section level2">
<h2><span class="header-section-number">4.3</span> Comparing differential expression calls within and across SEQC groups</h2>
<p>The SEQC dataset includes transcriptomes from two different cell lines (“A” and “B”), as well as from two mixtures of those cell lines (“C” and “D”), each with 5 replicates. Contrarily to the two previous cases, here the truth of differential expression is not known, and the working assumption behind this dataset is that a detected differential expression between groups (i.e. cell-lines or mixtures) is putatively true, while a detected differential expression within groups (i.e. between replicates of a given sample) is a false positive. Plotting the number of genes in both comparisons that a below a sliding p-value threshold therefore gives a picture analogous to the ROC curve, which in the context of this package we’ll call a “positives curve”.</p>
<p>Given the relevant comparisons, such curves can be produced by the <code>posplot()</code> function (see <code>?posplot</code> for more information). Alternatively, additional functions take care of generating the relevant comparisons and plotting the results: see especially <code>?seqc.diff</code> and <code>?seqc.diff.plot</code>. Here, we’ll showcase these functions using the <code>seqc.diff.example()</code> function, which fetches an existing quantification from the <code>seqc</code> package, performs the relevant comparisons using three DEA methods, and plots the results. Alternatively, you could use your own quantification of the SEQC data (see <code>?seqc.diff</code> and <code>?seqc.diff.example</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">seqc.diff.example</span>()
## Loading required package: seqc
## # Fetching and preparing SEQC data from the BGI site...
## 
##  #  edgeR
## # Running background differential expression analyses
## A(1, 2, 3) vs A(4, 5)
## B(1, 2, 3) vs B(4, 5)
## C(1, 2, 3) vs C(4, 5)
## D(1, 2, 3) vs D(4, 5)
## # Running differential expression analysis A vs B
## # Running differential expression analysis C vs D
## 
##  #  voom
## # Running background differential expression analyses
## A(1, 2, 3) vs A(4, 5)
## B(1, 2, 3) vs B(4, 5)
## C(1, 2, 3) vs C(4, 5)
## D(1, 2, 3) vs D(4, 5)
## # Running differential expression analysis A vs B
## # Running differential expression analysis C vs D
## 
##  #  DESeq2
## # Running background differential expression analyses
## A(1, 2, 3) vs A(4, 5)
## B(1, 2, 3) vs B(4, 5)
## C(1, 2, 3) vs C(4, 5)
## D(1, 2, 3) vs D(4, 5)
## # Running differential expression analysis A vs B
## # Running differential expression analysis C vs D
## Producing plots for A vs B comparison
## Producing plots for C vs D comparison</code></pre></div>
<p><img src="figure-html/seqcDiffEG-1.png"/></p
<p>The function produces 4 plots, the right-hand ones being simply a zoom-in of the left ones. The top row represents the comparison between cell lines A and B, which the bottom row represents the comparison of C and D, which are two different mixtures of cell lines A and B. The results can be roughly read as a ROC curve, with the important caveat that true positives are simply assumed to be true.</p>
<p>Of note, the cell lines are <em>very</em> different from one another, and the high degree of replication makes this a rather simple task for differential expression analysis. For this reason, we would recommend concentrating on the (slightly more subtle) C vs D comparison, and eventually to reduce the number of replicates used. This can all be done using the <code>between.groups</code> and <code>inner.groups</code> paramters of the <code>seqc.diff()</code> and <code>seqc.diff.example()</code> functions (see <code>?seqc.diff</code>). The default parameter values <code>between.groups=1:5, inner.groups=list(c(1,2,3),c(4,5))</code> indicate that replicates 1 to 5 will be used for comparison between groups, while for comparison within group replicates c(1,2,3) will be compared to replicates c(4,5) in each group.</p>
</div>
</div>
<div id="reporting-issues" class="section level1">
<h1><span class="header-section-number">5</span> Reporting issues</h1>
<p>Please report issues on the <a href="https://github.com/plger/RNAontheBENCH">github repository</a>.</p>
</div>

</div>

</body>
</html>
